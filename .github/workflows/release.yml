name: Create Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'The semantic version for the release (e.g., 1.2.3)'
        required: true
        type: string
      publish_to_nuget:
        description: 'Push packages to NuGet.org? (true/false)'
        required: true
        type: boolean
        default: false

permissions:
  contents: write
  actions: read

jobs:
  release:
    name: Build, Package, and Release
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Trigger and Wait for Native Builds
        id: native_builds
        env:
          GH_TOKEN: ${{ secrets.WORKFLOW_TOKEN }}
          BRANCH_REF: ${{ github.ref_name }}
        run: |
          set -e # Exit immediately if a command fails
          
          # Define Workflows and an associative array for their IDs
          declare -A WORKFLOWS=(
            ["webrtc"]="build-extensions-apm.yml"
            ["ffmpeg"]="build-ffmpeg.yml"
            ["miniaudio"]="build-miniaudio.yml"
            ["portmidi"]="build-portmidi.yml"
          )
          declare -A RUN_IDS

          # Step 1: Trigger all workflows in parallel
          echo "Triggering native build workflows on ref: $BRANCH_REF"
          for key in "${!WORKFLOWS[@]}"; do
            gh workflow run "${WORKFLOWS[$key]}" --ref "$BRANCH_REF" &
          done
          wait # Wait for all background trigger jobs to finish
          
          echo "All workflows triggered. Waiting a moment for them to appear on the API..."
          sleep 15 # Give GitHub API a moment to create the run entries
          
          # Step 2: Find the run IDs for the workflows we just started
          echo "Fetching run IDs for commit ${{ github.sha }}..."
          for key in "${!WORKFLOWS[@]}"; do
            run_id=$(gh run list --workflow="${WORKFLOWS[$key]}" --branch "$BRANCH_REF" --json databaseId,headSha -q '.[] | select(.headSha=="${{ github.sha }}") | .databaseId' | head -n 1)
            if [[ -z "$run_id" ]]; then
              echo "Error: Could not find the run ID for ${WORKFLOWS[$key]}."
              exit 1
            fi
            RUN_IDS[$key]=$run_id
            echo "  => Found Run ID for $key: ${RUN_IDS[$key]}"
          done

          # Set outputs for download steps. These names must match the download steps below.
          echo "webrtc_run_id=${RUN_IDS[webrtc]}" >> "$GITHUB_OUTPUT"
          echo "ffmpeg_run_id=${RUN_IDS[ffmpeg]}" >> "$GITHUB_OUTPUT"
          echo "miniaudio_run_id=${RUN_IDS[miniaudio]}" >> "$GITHUB_OUTPUT"
          echo "portmidi_run_id=${RUN_IDS[portmidi]}" >> "$GITHUB_OUTPUT"
          
          # Step 3: Wait for all runs to complete
          echo "Waiting for all build workflows to complete... (Polling every 1 minute)"
          
          # Run 'watch' for each in the background with a 60-second interval
          for id in "${RUN_IDS[@]}"; do
            gh run watch "$id" --interval 60 &
          done
          wait # Wait for all 'watch' commands to finish
          
          # Step 4: Check final conclusions
          echo "All workflows have completed. Checking final conclusions..."
          
          all_successful=true
          for key in "${!RUN_IDS[@]}"; do
            conclusion=$(gh run view "${RUN_IDS[$key]}" --json conclusion -q .conclusion)
            echo "  => ${WORKFLOWS[$key]} conclusion: $conclusion"
            if [[ "$conclusion" != "success" ]]; then
              all_successful=false
            fi
          done

          if [[ "$all_successful" != true ]]; then
            echo "One or more native build workflows failed."
            exit 1
          fi

          echo "All native build workflows completed successfully."

      - name: Download WebRTC APM Artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build-extensions-apm.yml
          name: webrtc-audio-processing
          path: native-artifacts/webrtc-audio-processing
          run_id: ${{ steps.native_builds.outputs.webrtc_run_id }}

      - name: Download FFmpeg Artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build-ffmpeg.yml
          name: soundflow-ffmpeg-runtimes
          path: native-artifacts/soundflow-ffmpeg-runtimes
          run_id: ${{ steps.native_builds.outputs.ffmpeg_run_id }}

      - name: Download Miniaudio Artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build-miniaudio.yml
          name: miniaudio-native-libraries
          path: native-artifacts/miniaudio-native-libraries
          run_id: ${{ steps.native_builds.outputs.miniaudio_run_id }}

      - name: Download PortMidi Artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: build-portmidi.yml
          name: portmidi-native-libraries
          path: native-artifacts/portmidi-native-libraries
          run_id: ${{ steps.native_builds.outputs.portmidi_run_id }}

      - name: Extract and Place Runtimes
        run: |
          # Miniaudio
          unzip native-artifacts/miniaudio-native-libraries/miniaudio-native-libraries.zip -d temp_unzip
          rm -rf Src/Backends/MiniAudio/runtimes
          mv temp_unzip/runtimes Src/Backends/MiniAudio/
          rm -rf temp_unzip

          # PortMidi
          unzip native-artifacts/portmidi-native-libraries/portmidi-native-libraries.zip -d temp_unzip
          rm -rf Midi/SoundFlow.Midi.PortMidi/runtimes
          mv temp_unzip/runtimes Midi/SoundFlow.Midi.PortMidi/
          rm -rf temp_unzip

          # WebRTC APM
          unzip native-artifacts/webrtc-audio-processing/webrtc-audio-processing.zip -d temp_unzip
          rm -rf Extensions/SoundFlow.Extensions.WebRtc.Apm/runtimes
          mv temp_unzip/runtimes Extensions/SoundFlow.Extensions.WebRtc.Apm/
          rm -rf temp_unzip

          # FFmpeg
          unzip native-artifacts/soundflow-ffmpeg-runtimes/soundflow-ffmpeg-runtimes.zip -d temp_unzip
          rm -rf Codecs/SoundFlow.Codecs.FFMpeg/runtimes
          mv temp_unzip/runtimes Codecs/SoundFlow.Codecs.FFMpeg/
          rm -rf temp_unzip

          echo "All runtimes have been placed."

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Update Project Versions
        run: |
          VERSION=${{ inputs.version }}
          CSPROJ_FILES=(
            "Src/SoundFlow.csproj"
            "Codecs/SoundFlow.Codecs.FFMpeg/SoundFlow.Codecs.FFMpeg.csproj"
            "Extensions/SoundFlow.Extensions.WebRtc.Apm/SoundFlow.Extensions.WebRtc.Apm.csproj"
            "Midi/SoundFlow.Midi.PortMidi/SoundFlow.Midi.PortMidi.csproj"
          )
          for file in "${CSPROJ_FILES[@]}"; do
            echo "Updating version in $file to $VERSION"
            sed -i "s|<Version>.*</Version>|<Version>$VERSION</Version>|" "$file"
          done

      - name: Create NuGet Packages
        run: |
          mkdir -p ./packages
          dotnet pack Src/SoundFlow.csproj --configuration Release -o ./packages
          dotnet pack Codecs/SoundFlow.Codecs.FFMpeg/SoundFlow.Codecs.FFMpeg.csproj --configuration Release -o ./packages
          dotnet pack Extensions/SoundFlow.Extensions.WebRtc.Apm/SoundFlow.Extensions.WebRtc.Apm.csproj --configuration Release -o ./packages
          dotnet pack Midi/SoundFlow.Midi.PortMidi/SoundFlow.Midi.PortMidi.csproj --configuration Release -o ./packages

      - name: Push Packages to NuGet.org
        if: inputs.publish_to_nuget == true
        run: dotnet nuget push "packages/*.nupkg" --source "https://api.nuget.org/v3/index.json" --api-key ${{ secrets.NUGET_API_KEY }} --skip-duplicate

      - name: Commit to Release Branch, Tag, and Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b release/v${{ inputs.version }}
          git add ./**/*.csproj
          git commit -m "chore: Bump version to ${{ inputs.version }}"
          git push origin release/v${{ inputs.version }}
          git tag -a "v${{ inputs.version }}" -m "Release version v${{ inputs.version }}"
          git push origin "v${{ inputs.version }}"

      - name: Upload NuGet Packages as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages-${{ inputs.version }}
          path: ./packages/*.nupkg